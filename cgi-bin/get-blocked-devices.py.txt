#!/usr/bin/env python3
"""
OpenWrt Blocked Devices Script (Access Control Rules)
Returns list of devices blocked by access control firewall rules
Updated to work with access-rule- prefix format
"""

import json
import subprocess
import re
import time
from typing import Dict, List, Optional, Tuple

# Configuration
ACCESS_RULE_PREFIX = "access-rule-"
BLOCK_RULE_PREFIX = "Block_"

def run_command(cmd: str) -> str:
    """Execute shell command and return output"""
    try:
        result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=10)
        return result.stdout.strip()
    except Exception:
        return ""

def get_arp_table() -> str:
    """Get ARP table contents"""
    try:
        with open('/proc/net/arp', 'r') as f:
            return f.read()
    except Exception:
        return ""

def get_dhcp_leases() -> str:
    """Get DHCP leases contents"""
    try:
        with open('/var/dhcp.leases', 'r') as f:
            return f.read()
    except Exception:
        return ""

def normalize_mac(mac: str) -> str:
    """Normalize MAC address format to uppercase with colons"""
    if not mac:
        return ""
    # Remove any separators and convert to uppercase
    clean_mac = re.sub(r'[:-]', '', mac.upper())
    # Add colons every 2 characters
    if len(clean_mac) == 12:
        return ':'.join(clean_mac[i:i+2] for i in range(0, 12, 2))
    return mac.upper()

def get_hostname_from_mac(mac: str, dhcp_leases: str) -> Optional[str]:
    """Get hostname from MAC address using DHCP leases"""
    normalized_mac = normalize_mac(mac)

    for line in dhcp_leases.split('\n'):
        if line.strip():
            parts = line.split()
            if len(parts) >= 4:
                lease_mac = normalize_mac(parts[1])
                if lease_mac == normalized_mac:
                    hostname = parts[3]
                    if hostname != "*" and hostname:
                        return hostname
    return None

def get_ip_from_mac(mac: str, arp_table: str, dhcp_leases: str) -> Optional[str]:
    """Get IP address from MAC address using ARP table and DHCP leases"""
    normalized_mac = normalize_mac(mac)

    # Try ARP table first
    for line in arp_table.split('\n'):
        if line.strip():
            parts = line.split()
            if len(parts) >= 4:
                arp_mac = normalize_mac(parts[3])
                if arp_mac == normalized_mac:
                    return parts[0]

    # Try DHCP leases
    for line in dhcp_leases.split('\n'):
        if line.strip():
            parts = line.split()
            if len(parts) >= 4:
                lease_mac = normalize_mac(parts[1])
                if lease_mac == normalized_mac:
                    return parts[2]

    return None

def get_uci_value(path: str) -> str:
    """Get UCI configuration value"""
    cmd = f"uci -q get '{path}' 2>/dev/null"
    return run_command(cmd)

def get_firewall_rules() -> List[int]:
    """Get list of firewall rule numbers"""
    cmd = "uci show firewall 2>/dev/null | grep '=rule$'"
    output = run_command(cmd)

    rule_numbers = []
    for line in output.split('\n'):
        if line:
            # Extract rule number from firewall.@rule[X]=rule
            match = re.search(r'firewall\.@rule\[(\d+)\]', line)
            if match:
                rule_numbers.append(int(match.group(1)))

    return sorted(rule_numbers)

def is_blocked_device_rule(rule_details: Dict[str, str]) -> bool:
    """Check if a rule is a blocked device rule (Block_ prefix only)"""
    name = rule_details.get('name', '')
    src_mac = rule_details.get('src_mac')
    target = rule_details.get('target')

    # Must have src_mac and be a blocking target
    if not src_mac or target not in ['REJECT', 'DROP']:
        return False

    # Only check for Block_ prefix (exclude parental controls)
    if name.startswith(BLOCK_RULE_PREFIX):
        return True

    return False

def is_parental_control_rule(rule_details: Dict[str, str]) -> bool:
    """Check if a rule is a parental control rule"""
    name = rule_details.get('name', '')
    start_time = rule_details.get('start_time')
    src_mac = rule_details.get('src_mac')
    dest_ip = rule_details.get('dest_ip')
    dest_port = rule_details.get('dest_port')
    weekdays = rule_details.get('weekdays')

    # Check parental control criteria
    if name and "parental" in name.lower():
        return True
    if start_time or weekdays:
        return True
    # More specific check: MAC + specific dest_ip + port restrictions = parental control
    if src_mac and dest_ip and dest_port:
        return True

    return False

def get_rule_details(rule_num: int) -> Dict[str, str]:
    """Get all details for a firewall rule"""
    fields = ['name', 'src', 'dest', 'proto', 'src_mac', 'dest_ip', 'target',
              'start_time', 'stop_time', 'enabled', 'dest_port', 'src_port', 'weekdays']
    details = {}

    for field in fields:
        value = get_uci_value(f"firewall.@rule[{rule_num}].{field}")
        details[field] = value if value else None

    return details

def determine_block_type(rule_details: Dict[str, str]) -> str:
    """Determine the type of blocking rule"""
    name = rule_details.get('name', '')

    if is_time_based_rule(rule_details):
        return 'Time-based access control'
    elif name.startswith(ACCESS_RULE_PREFIX):
        return 'Access control rule'
    elif name.startswith(BLOCK_RULE_PREFIX):
        return 'Device blocking rule'
    else:
        return 'Firewall blocking rule'

def format_time_restriction(rule_details: Dict[str, str]) -> Optional[str]:
    """Format time restriction information"""
    start_time = rule_details.get('start_time')
    stop_time = rule_details.get('stop_time')
    weekdays = rule_details.get('weekdays')

    time_parts = []

    if start_time and stop_time:
        time_parts.append(f"from {start_time} to {stop_time}")
    elif start_time:
        time_parts.append(f"from {start_time}")
    elif stop_time:
        time_parts.append(f"until {stop_time}")

    if weekdays:
        time_parts.append(f"on {weekdays}")

    return " ".join(time_parts) if time_parts else None

def get_blocked_devices() -> List[Dict]:
    """Get list of blocked devices excluding parental controls"""
    blocked_devices = []

    # Get supporting data
    arp_table = get_arp_table()
    dhcp_leases = get_dhcp_leases()

    # Get all firewall rules
    rule_numbers = get_firewall_rules()

    for rule_num in rule_numbers:
        # Get rule details
        rule_details = get_rule_details(rule_num)

        src_mac = rule_details.get('src_mac')
        target = rule_details.get('target')
        enabled = rule_details.get('enabled')

        # Skip if not a blocked device rule (Block_ prefix only)
        if not is_blocked_device_rule(rule_details):
            continue

        # Skip disabled rules
        if enabled == '0':
            continue

        # Skip parental control rules
        if is_parental_control_rule(rule_details):
            continue

        # Normalize MAC address
        if src_mac:
            src_mac = normalize_mac(src_mac)

        # Get IP address and hostname
        ip = get_ip_from_mac(src_mac, arp_table, dhcp_leases) if src_mac else None
        hostname = get_hostname_from_mac(src_mac, dhcp_leases) if src_mac else None

        # Build device info
        device_info = {
            'mac': src_mac,
            'ip': ip,
            'hostname': hostname,
            'name': rule_details.get('name'),
            'block_type': 'MAC address',
            'src': rule_details.get('src'),
            'dest': rule_details.get('dest'),
            'proto': rule_details.get('proto'),
            'target': target,
            'enabled': rule_details.get('enabled'),
            'rule_number': str(rule_num)
        }

        blocked_devices.append(device_info)

    return blocked_devices

def get_device_statistics(permanently_blocked: List[Dict], time_restricted: List[Dict]) -> Dict:
    """Generate statistics about blocked devices"""
    total_rules = len(permanently_blocked) + len(time_restricted)

    # Count by target type
    reject_count = sum(1 for d in permanently_blocked + time_restricted if d.get('target') == 'REJECT')
    drop_count = sum(1 for d in permanently_blocked + time_restricted if d.get('target') == 'DROP')

    # Count by rule prefix
    access_rule_count = sum(1 for d in permanently_blocked + time_restricted
                           if d.get('rule_name', '').startswith(ACCESS_RULE_PREFIX))
    block_rule_count = sum(1 for d in permanently_blocked + time_restricted
                          if d.get('rule_name', '').startswith(BLOCK_RULE_PREFIX))

    return {
        'total_blocked_devices': total_rules,
        'permanently_blocked': len(permanently_blocked),
        'time_restricted': len(time_restricted),
        'reject_rules': reject_count,
        'drop_rules': drop_count,
        'access_rules': access_rule_count,
        'block_rules': block_rule_count
    }

def main():
    """Main function to generate JSON response"""
    # Set CGI headers
    print("Content-type: application/json")
    print("Cache-Control: no-cache")
    print()  # Empty line required after headers

    try:
        # Get blocked devices
        blocked_devices = get_blocked_devices()

        # Build response
        response = {
            'timestamp': int(time.time()),
            'blocked_devices': blocked_devices
        }

        # Output JSON
        print(json.dumps(response, indent=2))

    except Exception as e:
        # Error response
        error_response = {
            'timestamp': int(time.time()),
            'error': str(e),
            'blocked_devices': []
        }
        print(json.dumps(error_response, indent=2))

if __name__ == '__main__':
    main()