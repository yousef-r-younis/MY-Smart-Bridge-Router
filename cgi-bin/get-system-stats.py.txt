#!/usr/bin/env python3

import json
import subprocess
import sys
import time
import os
from datetime import datetime, timezone
from pathlib import Path
import argparse

# For CGI usage, set content type first
if os.environ.get('GATEWAY_INTERFACE'):
    print("Content-Type: application/json")
    print()  # Empty line required between headers and body

class SystemStats:
    def __init__(self):
        self.cpu_prev_file = Path("/tmp/cpu_prev_total")
        self.cache_dir = Path("/tmp/dashboard_cache")
        self.cache_dir.mkdir(exist_ok=True)

    def safe_read_file(self, filepath, default=""):
        """Safely read file with fallback"""
        try:
            return Path(filepath).read_text().strip()
        except:
            return default

    def safe_float(self, value, default=0.0):
        """Safely convert to float with fallback"""
        try:
            return float(value)
        except:
            return default

    def safe_int(self, value, default=0):
        """Safely convert to int with fallback"""
        try:
            return int(value)
        except:
            return default

    def get_hostname(self):
        """Get system hostname"""
        try:
            return subprocess.check_output(['uname', '-n'], text=True).strip()
        except:
            return "Unknown"

    def get_uptime(self):
        """Get system uptime information"""
        try:
            uptime_data = self.safe_read_file("/proc/uptime", "0 0")
            uptime_seconds = self.safe_int(float(uptime_data.split()[0]))

            days = uptime_seconds // 86400
            hours = (uptime_seconds % 86400) // 3600
            minutes = (uptime_seconds % 3600) // 60

            return {
                "seconds": uptime_seconds,
                "days": days,
                "hours": hours,
                "minutes": minutes,
                "formatted": f"{days}d {hours}h {minutes}m"
            }
        except:
            return {"seconds": 0, "days": 0, "hours": 0, "minutes": 0, "formatted": "0d 0h 0m"}

    def get_load_average(self):
        """Get system load averages"""
        try:
            loadavg_data = self.safe_read_file("/proc/loadavg", "0 0 0")
            parts = loadavg_data.split()
            return {
                "1min": self.safe_float(parts[0]),
                "5min": self.safe_float(parts[1]),
                "15min": self.safe_float(parts[2])
            }
        except:
            return {"1min": 0.0, "5min": 0.0, "15min": 0.0}

    def get_memory_info(self):
        """Get memory usage information"""
        try:
            meminfo = self.safe_read_file("/proc/meminfo", "")
            if not meminfo:
                return None

            # Parse memory info
            mem_data = {}
            for line in meminfo.split('\n'):
                if ':' in line:
                    key, value = line.split(':', 1)
                    mem_data[key.strip()] = self.safe_int(value.strip().split()[0])

            mem_total = mem_data.get('MemTotal', 1)
            mem_available = mem_data.get('MemAvailable')

            if mem_available is None:
                # Fallback calculation for older systems
                mem_free = mem_data.get('MemFree', 0)
                mem_buffers = mem_data.get('Buffers', 0)
                mem_cached = mem_data.get('Cached', 0)
                mem_available = mem_free + mem_buffers + mem_cached

            mem_used = mem_total - mem_available
            mem_percent = (mem_used / mem_total * 100) if mem_total > 0 else 0

            return {
                "total_mb": round(mem_total / 1024, 1),
                "used_mb": round(mem_used / 1024, 1),
                "available_mb": round(mem_available / 1024, 1),
                "used_percent": round(mem_percent, 1)
            }
        except:
            return None

    def get_cpu_temperature(self):
        """Get CPU temperature from various sources"""
        temp_paths = [
            "/sys/class/thermal/thermal_zone0/temp",
            "/sys/devices/virtual/thermal/thermal_zone0/temp",
            "/sys/class/hwmon/hwmon0/temp1_input"
        ]

        for temp_path in temp_paths:
            try:
                temp_raw = self.safe_read_file(temp_path)
                if temp_raw and temp_raw.isdigit():
                    temp_value = int(temp_raw) / 1000.0
                    if temp_value > 0:
                        return round(temp_value, 1)
            except:
                continue

        return None

    def get_cpu_usage(self):
        """Get CPU usage percentage"""
        try:
            stat_data = self.safe_read_file("/proc/stat", "")
            if not stat_data:
                return None

            # Parse first CPU line (overall)
            cpu_line = None
            for line in stat_data.split('\n'):
                if line.startswith('cpu '):
                    cpu_line = line
                    break

            if not cpu_line:
                return None

            # Parse CPU values
            parts = cpu_line.split()
            if len(parts) < 8:
                return None

            user = self.safe_int(parts[1])
            nice = self.safe_int(parts[2])
            system = self.safe_int(parts[3])
            idle = self.safe_int(parts[4])
            iowait = self.safe_int(parts[5])
            irq = self.safe_int(parts[6])
            softirq = self.safe_int(parts[7])

            total = user + nice + system + idle + iowait + irq + softirq

            # Read previous values
            if self.cpu_prev_file.exists():
                try:
                    prev_data = self.cpu_prev_file.read_text().strip().split()
                    prev_total = self.safe_int(prev_data[0])
                    prev_idle = self.safe_int(prev_data[1])

                    total_diff = total - prev_total
                    idle_diff = idle - prev_idle

                    if total_diff > 0:
                        usage = (1 - (idle_diff / total_diff)) * 100
                        usage = max(0, min(100, usage))  # Clamp between 0-100

                        # Save current values for next calculation
                        self.cpu_prev_file.write_text(f"{total} {idle}")

                        return round(usage, 1)
                except:
                    pass

            # Save current values for next time
            self.cpu_prev_file.write_text(f"{total} {idle}")
            return None  # Need two readings for calculation

        except:
            return None

    def get_all_stats(self):
        """Get all system statistics"""
        return {
            "hostname": self.get_hostname(),
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "uptime": self.get_uptime(),
            "load": self.get_load_average(),
            "memory": self.get_memory_info(),
            "cpu_usage_percent": self.get_cpu_usage(),
            "cpu_temperature": self.get_cpu_temperature()
        }

    def get_health_status(self):
        """Get simplified health status"""
        uptime = self.get_uptime()
        load = self.get_load_average()
        memory = self.get_memory_info()

        # Determine health status
        health = "good"
        issues = []

        if load["1min"] > 4.0:
            health = "warning"
            issues.append(f"High load: {load['1min']:.2f}")

        if memory and memory["used_percent"] > 90:
            health = "warning"
            issues.append(f"High memory usage: {memory['used_percent']:.1f}%")

        if uptime["seconds"] < 300:  # Recently rebooted
            if health == "good":
                health = "info"
            issues.append("Recently rebooted")

        return {
            "health": health,
            "issues": issues,
            "uptime_seconds": uptime["seconds"],
            "load_1min": load["1min"],
            "memory_percent": memory["used_percent"] if memory else None
        }

def main():
    try:
        # Check if running as CGI
        is_cgi = os.environ.get('GATEWAY_INTERFACE') is not None

        if is_cgi:
            # CGI mode - always output JSON and handle query string
            stats = SystemStats()

            # Parse query string for action
            query_string = os.environ.get('QUERY_STRING', '')
            if 'health' in query_string:
                result = stats.get_health_status()
            elif 'uptime' in query_string:
                result = stats.get_uptime()
            elif 'load' in query_string:
                result = stats.get_load_average()
            elif 'memory' in query_string:
                result = stats.get_memory_info()
            elif 'cpu' in query_string:
                result = {"cpu_usage_percent": stats.get_cpu_usage()}
            elif 'temp' in query_string:
                result = {"cpu_temperature": stats.get_cpu_temperature()}
            else:
                result = stats.get_all_stats()

            print(json.dumps(result, indent=2))
            return

        # Command line mode
        parser = argparse.ArgumentParser(description='Get system statistics')
        parser.add_argument('--all', action='store_true', help='Show all statistics')
        parser.add_argument('--uptime', action='store_true', help='Show uptime only')
        parser.add_argument('--load', action='store_true', help='Show load average only')
        parser.add_argument('--memory', action='store_true', help='Show memory info only')
        parser.add_argument('--cpu', action='store_true', help='Show CPU info only')
        parser.add_argument('--temp', action='store_true', help='Show temperature only')
        parser.add_argument('--health', action='store_true', help='Show health status')
        parser.add_argument('--json', action='store_true', help='Output in JSON format')

        args = parser.parse_args()
        stats = SystemStats()

        if args.all or (not any([args.uptime, args.load, args.memory, args.cpu, args.temp, args.health])):
            result = stats.get_all_stats()
        elif args.health:
            result = stats.get_health_status()
        elif args.uptime:
            result = stats.get_uptime()
        elif args.load:
            result = stats.get_load_average()
        elif args.memory:
            result = stats.get_memory_info()
        elif args.cpu:
            result = {"cpu_usage_percent": stats.get_cpu_usage()}
        elif args.temp:
            result = {"cpu_temperature": stats.get_cpu_temperature()}

        if args.json:
            print(json.dumps(result, indent=2))
        else:
            # Pretty print based on what was requested
            if args.all or (not any([args.uptime, args.load, args.memory, args.cpu, args.temp, args.health])):
                print(f"Hostname: {result['hostname']}")
                print(f"Uptime: {result['uptime']['formatted']}")
                print(f"Load: {result['load']['1min']:.2f}, {result['load']['5min']:.2f}, {result['load']['15min']:.2f}")
                if result['memory']:
                    print(f"Memory: {result['memory']['used_percent']:.1f}% used ({result['memory']['used_mb']:.1f}/{result['memory']['total_mb']:.1f} MB)")
                if result['cpu_usage_percent'] is not None:
                    print(f"CPU Usage: {result['cpu_usage_percent']:.1f}%")
                if result['cpu_temperature'] is not None:
                    print(f"CPU Temperature: {result['cpu_temperature']:.1f}°C")
            elif args.health:
                print(f"Health: {result['health']}")
                if result['issues']:
                    print(f"Issues: {', '.join(result['issues'])}")
            else:
                # Simple output for individual stats
                if isinstance(result, dict) and len(result) == 1:
                    key, value = next(iter(result.items()))
                    if value is not None:
                        print(f"{key}: {value}")
                    else:
                        print(f"{key}: Not available")
                else:
                    print(json.dumps(result, indent=2))

    except Exception as e:
        # Error handling for CGI
        if os.environ.get('GATEWAY_INTERFACE'):
            error_response = {
                "error": f"System stats error: {str(e)}",
                "success": False,
                "timestamp": datetime.now(timezone.utc).isoformat()
            }
            print(json.dumps(error_response, indent=2))
        else:
            print(f"Error: {e}", file=sys.stderr)
            sys.exit(1)

if __name__ == "__main__":
    main()