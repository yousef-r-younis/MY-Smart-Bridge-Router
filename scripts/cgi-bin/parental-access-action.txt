#!/bin/sh

echo "Content-Type: application/json"
echo "Cache-Control: no-cache"
echo ""

# Parse query string and POST data
parse_query() {
    if [ "$REQUEST_METHOD" = "POST" ]; then
        read -r QUERY_STRING
    fi

    # Parse parameters
    ACTION=$(echo "$QUERY_STRING" | sed -n 's/.*action=\([^&]*\).*/\1/p' | sed 's/%20/ /g')
    RULE_NAME=$(echo "$QUERY_STRING" | sed -n 's/.*name=\([^&]*\).*/\1/p' | sed 's/%20/ /g')
    NAME_PREFIX=$(echo "$QUERY_STRING" | sed -n 's/.*prefix=\([^&]*\).*/\1/p' | sed 's/%20/ /g')
    MAC_ADDR=$(echo "$QUERY_STRING" | sed -n 's/.*mac=\([^&]*\).*/\1/p' | sed 's/%3A/:/g')
    START_TIME=$(echo "$QUERY_STRING" | sed -n 's/.*start_time=\([^&]*\).*/\1/p' | sed 's/%3A/:/g')
    STOP_TIME=$(echo "$QUERY_STRING" | sed -n 's/.*stop_time=\([^&]*\).*/\1/p' | sed 's/%3A/:/g')
    WEEKDAYS=$(echo "$QUERY_STRING" | sed -n 's/.*weekdays=\([^&]*\).*/\1/p' | sed 's/%20/ /g')
}

# Function to get next available rule index
get_next_rule_index() {
    local index=0
    local existing_indices

    # Get unique rule indices (each rule appears multiple times due to properties)
    existing_indices=$(uci show firewall | grep "@rule\[" | cut -d'[' -f2 | cut -d']' -f1 | sort -n | uniq)

    # Find the first gap or use the next number after the highest
    for existing_index in $existing_indices; do
        if [ "$index" -lt "$existing_index" ]; then
            # Found a gap, use this index
            echo "$index"
            return
        fi
        index=$((existing_index + 1))
    done

    # No gaps found, use the next number after the highest
    echo "$index"
}

# Function to find rule index by name (only access-filter- rules)
find_rule_by_name() {
    local rule_name="$1"
    local rule_index

    # Only search for rules that start with "access-filter-"
    case "$rule_name" in
        access-filter-*)
            rule_index=$(uci show firewall | grep "\.name='$rule_name'" | cut -d'[' -f2 | cut -d']' -f1)
            echo "$rule_index"
            ;;
        *)
            # If rule doesn't start with access-filter-, return empty
            echo ""
            ;;
    esac
}

# Function to add firewall rule (automatically prefixes with access-filter-)
add_rule() {
    local rule_name="$1"
    local mac_addr="$2"
    local start_time="$3"
    local stop_time="$4"
    local weekdays="$5"

    # Validate required parameters
    if [ -z "$rule_name" ] || [ -z "$mac_addr" ]; then
        echo '{"status": "error", "message": "Rule name and MAC address are required"}'
        return 1
    fi

    # Automatically add access-filter- prefix if not present
    case "$rule_name" in
        access-filter-*)
            # Already has prefix
            ;;
        *)
            rule_name="access-filter-$rule_name"
            ;;
    esac

    # Check if rule already exists
    if [ -n "$(find_rule_by_name "$rule_name")" ]; then
        echo '{"status": "error", "message": "Rule with this name already exists"}'
        return 1
    fi

    # Get next available index
    local rule_index=$(get_next_rule_index)

    # Double-check that the index is actually available
    local existing_rule=$(uci get firewall.@rule[$rule_index].name 2>/dev/null)
    if [ -n "$existing_rule" ]; then
        # Index is occupied, find another one by brute force
        local test_index=0
        while [ $test_index -lt 100 ]; do
            existing_rule=$(uci get firewall.@rule[$test_index].name 2>/dev/null)
            if [ -z "$existing_rule" ]; then
                rule_index=$test_index
                break
            fi
            test_index=$((test_index + 1))
        done

        # If we still couldn't find an available index after checking 100 slots
        if [ -n "$(uci get firewall.@rule[$rule_index].name 2>/dev/null)" ]; then
            echo '{"status": "error", "message": "Could not find available rule index"}'
            return 1
        fi
    fi

    # Try to add a new rule section first
    if ! uci add firewall rule >/dev/null 2>&1; then
        echo '{"status": "error", "message": "Failed to add rule section"}'
        return 1
    fi

    # Get the actual index that was created
    local actual_index
    actual_index=$(uci show firewall | grep "@rule\[" | tail -1 | cut -d'[' -f2 | cut -d']' -f1)

    if [ -z "$actual_index" ]; then
        echo '{"status": "error", "message": "Failed to determine rule index"}'
        return 1
    fi

    # Set rule properties on the newly created rule
    if ! uci set firewall.@rule[$actual_index].name="$rule_name" ||
       ! uci set firewall.@rule[$actual_index].src_mac="$mac_addr" ||
       ! uci set firewall.@rule[$actual_index].src='*' ||
       ! uci set firewall.@rule[$actual_index].dest='wan' ||
       ! uci set firewall.@rule[$actual_index].proto='all' ||
       ! uci set firewall.@rule[$actual_index].target='REJECT'; then
        echo '{"status": "error", "message": "Failed to set rule properties"}'
        uci delete firewall.@rule[$actual_index] 2>/dev/null
        return 1
    fi

    # Add time restrictions if provided
    if [ -n "$start_time" ] && [ -n "$stop_time" ]; then
        if ! uci set firewall.@rule[$actual_index].start_time="$start_time" ||
           ! uci set firewall.@rule[$actual_index].stop_time="$stop_time"; then
            echo '{"status": "error", "message": "Failed to set time restrictions"}'
            uci delete firewall.@rule[$actual_index] 2>/dev/null
            return 1
        fi
    fi

    # Add weekdays if provided
    if [ -n "$weekdays" ]; then
        if ! uci set firewall.@rule[$actual_index].weekdays="$weekdays"; then
            echo '{"status": "error", "message": "Failed to set weekdays"}'
            uci delete firewall.@rule[$actual_index] 2>/dev/null
            return 1
        fi
    fi

    # Commit changes
    if uci commit firewall; then
        # Restart firewall
        /etc/init.d/firewall restart >/dev/null 2>&1
        echo "{\"status\": \"success\", \"message\": \"Rule '$rule_name' added successfully\", \"index\": $actual_index}"
    else
        echo '{"status": "error", "message": "Failed to commit firewall changes"}'
        uci delete firewall.@rule[$actual_index] 2>/dev/null
        return 1
    fi
}

# Function to remove firewall rule (only access-filter- rules)
remove_rule() {
    local rule_name="$1"

    if [ -z "$rule_name" ]; then
        echo '{"status": "error", "message": "Rule name is required"}'
        return 1
    fi

    # Automatically add access-filter- prefix if not present
    case "$rule_name" in
        access-filter-*)
            # Already has prefix
            ;;
        *)
            rule_name="access-filter-$rule_name"
            ;;
    esac

    # Find rule index
    local rule_index=$(find_rule_by_name "$rule_name")

    if [ -z "$rule_index" ]; then
        echo '{"status": "error", "message": "Rule not found or not an access-filter rule"}'
        return 1
    fi

    # Remove the rule
    if uci delete firewall.@rule[$rule_index] && uci commit firewall; then
        # Restart firewall
        /etc/init.d/firewall restart
        echo "{\"status\": \"success\", \"message\": \"Rule '$rule_name' removed successfully\"}"
    else
        echo '{"status": "error", "message": "Failed to remove rule"}'
        return 1
    fi
}

# Function to get access-filter rules
get_rules() {
    local rule_name="$1"

    if [ -n "$rule_name" ]; then
        # Automatically add access-filter- prefix if not present
        case "$rule_name" in
            access-filter-*)
                # Already has prefix
                ;;
            *)
                rule_name="access-filter-$rule_name"
                ;;
        esac

        # Get specific rule
        local rule_index=$(find_rule_by_name "$rule_name")

        if [ -z "$rule_index" ]; then
            echo '{"status": "error", "message": "Rule not found or not an access-filter rule"}'
            return 1
        fi

        local name=$(uci get firewall.@rule[$rule_index].name 2>/dev/null)
        local src_mac=$(uci get firewall.@rule[$rule_index].src_mac 2>/dev/null)
        local dest=$(uci get firewall.@rule[$rule_index].dest 2>/dev/null)
        local target=$(uci get firewall.@rule[$rule_index].target 2>/dev/null)
        local start_time=$(uci get firewall.@rule[$rule_index].start_time 2>/dev/null)
        local stop_time=$(uci get firewall.@rule[$rule_index].stop_time 2>/dev/null)
        local weekdays=$(uci get firewall.@rule[$rule_index].weekdays 2>/dev/null)

        echo "{\"status\": \"success\", \"rule\": {\"index\": $rule_index, \"name\": \"$name\", \"src_mac\": \"$src_mac\", \"dest\": \"$dest\", \"target\": \"$target\", \"start_time\": \"$start_time\", \"stop_time\": \"$stop_time\", \"weekdays\": \"$weekdays\"}}"
    else
        # Get all access-filter rules
        echo '{"status": "success", "rules": ['

        local first=1
        local count=0

        # Check each rule index from 0 to 50
        while [ $count -le 50 ]; do
            local name=$(uci get firewall.@rule[$count].name 2>/dev/null)
            local src_mac=$(uci get firewall.@rule[$count].src_mac 2>/dev/null)

            # Only include access-filter rules that have src_mac
            if [ -n "$src_mac" ] && [ -n "$name" ]; then
                case "$name" in
                    access-filter-*)
                        local dest=$(uci get firewall.@rule[$count].dest 2>/dev/null)
                        local target=$(uci get firewall.@rule[$count].target 2>/dev/null)
                        local start_time=$(uci get firewall.@rule[$count].start_time 2>/dev/null)
                        local stop_time=$(uci get firewall.@rule[$count].stop_time 2>/dev/null)
                        local weekdays=$(uci get firewall.@rule[$count].weekdays 2>/dev/null)

                        if [ $first -eq 0 ]; then
                            echo ","
                        fi
                        echo "{\"index\": $count, \"name\": \"$name\", \"src_mac\": \"$src_mac\", \"dest\": \"$dest\", \"target\": \"$target\", \"start_time\": \"$start_time\", \"stop_time\": \"$stop_time\", \"weekdays\": \"$weekdays\"}"
                        first=0
                        ;;
                esac
            fi
            count=$((count + 1))
        done

        echo ']}'
    fi
}

# Function to list rules by name prefix
list_rules_by_prefix() {
    local name_prefix="$1"

    if [ -z "$name_prefix" ]; then
        echo '{"status": "error", "message": "Name prefix is required"}'
        return 1
    fi

    echo '{"status": "success", "rules": ['

    local first=1
    local rule_sections=$(uci show firewall | grep "@rule\[" | grep "\.name=" | cut -d'[' -f2 | cut -d']' -f1 | sort -n)

    for rule_index in $rule_sections; do
        local name=$(uci get firewall.@rule[$rule_index].name 2>/dev/null)
        local src_mac=$(uci get firewall.@rule[$rule_index].src_mac 2>/dev/null)

        # Check if rule name starts with the specified prefix and has src_mac
        if [ -n "$src_mac" ] && [ -n "$name" ]; then
            case "$name" in
                "$name_prefix"*)
                    local dest=$(uci get firewall.@rule[$rule_index].dest 2>/dev/null)
                    local target=$(uci get firewall.@rule[$rule_index].target 2>/dev/null)
                    local start_time=$(uci get firewall.@rule[$rule_index].start_time 2>/dev/null)
                    local stop_time=$(uci get firewall.@rule[$rule_index].stop_time 2>/dev/null)
                    local weekdays=$(uci get firewall.@rule[$rule_index].weekdays 2>/dev/null)

                    if [ $first -eq 0 ]; then
                        echo ","
                    fi
                    echo "{\"index\": $rule_index, \"name\": \"$name\", \"src_mac\": \"$src_mac\", \"dest\": \"$dest\", \"target\": \"$target\", \"start_time\": \"$start_time\", \"stop_time\": \"$stop_time\", \"weekdays\": \"$weekdays\"}"
                    first=0
                    ;;
            esac
        fi
    done

    echo ']}'
}

# Function to validate MAC address format
validate_mac() {
    local mac="$1"
    echo "$mac" | grep -E '^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$' > /dev/null
}

# Function to validate time format
validate_time() {
    local time="$1"
    echo "$time" | grep -E '^[0-2][0-9]:[0-5][0-9]:[0-5][0-9]$' > /dev/null
}

# Main script logic
parse_query

case "$ACTION" in
    "add")
        # Validate MAC address format
        if [ -n "$MAC_ADDR" ] && ! validate_mac "$MAC_ADDR"; then
            echo '{"status": "error", "message": "Invalid MAC address format"}'
            exit 1
        fi

        # Validate time format if provided
        if [ -n "$START_TIME" ] && ! validate_time "$START_TIME"; then
            echo '{"status": "error", "message": "Invalid start time format (HH:MM:SS)"}'
            exit 1
        fi

        if [ -n "$STOP_TIME" ] && ! validate_time "$STOP_TIME"; then
            echo '{"status": "error", "message": "Invalid stop time format (HH:MM:SS)"}'
            exit 1
        fi

        add_rule "$RULE_NAME" "$MAC_ADDR" "$START_TIME" "$STOP_TIME" "$WEEKDAYS"
        ;;
    "remove")
        remove_rule "$RULE_NAME"
        ;;
    "get")
        get_rules "$RULE_NAME"
        ;;
    *)
        echo '{"status": "error", "message": "Invalid action. Use: add, remove, or get"}'
        exit 1
        ;;
esac