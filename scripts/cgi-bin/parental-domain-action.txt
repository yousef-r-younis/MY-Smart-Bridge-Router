#!/bin/sh

# CGI header for JSON
echo "Content-type: application/json"
echo ""

# Process CGI parameters
eval $(echo "$QUERY_STRING" | sed -e 's/&/;/g')

# Function to output JSON response
json_response() {
    local status="$1"
    local message="$2"
    local data="$3"

    echo "{"
    echo "  \"status\": \"$status\","
    echo "  \"message\": \"$message\""
    if [ -n "$data" ]; then
        echo "  ,\"data\": $data"
    fi
    echo "}"
}

# URL decode function
urldecode() {
    local url_encoded="${1//+/ }"
    printf '%b' "${url_encoded//%/\\x}"
}

# Function to list all custom filter rules
list_rules() {
    local rules_json="["
    local first=true

    # Loop through all firewall rules with name starting "custom-filter-"
    for section in $(uci show firewall 2>/dev/null | grep "firewall.*.name='custom-filter-" | cut -d. -f1-2); do
        local name=$(uci get $section.name 2>/dev/null)
        local domain=$(uci get $section.domain 2>/dev/null)
        local ip=$(uci get $section.dest_ip 2>/dev/null)
        local action=$(uci get $section.target 2>/dev/null)
        local src_mac=$(uci get $section.src_mac 2>/dev/null)
        local weekdays=$(uci get $section.weekdays 2>/dev/null)
        local start_time=$(uci get $section.start_time 2>/dev/null)
        local stop_time=$(uci get $section.stop_time 2>/dev/null)

        # Convert REJECT/ACCEPT back to block/allow
        if [ "$action" = "REJECT" ]; then
            action="block"
        elif [ "$action" = "ACCEPT" ]; then
            action="allow"
        fi

        [ "$first" = true ] || rules_json="$rules_json,"
        first=false

        rules_json="$rules_json{"
        rules_json="$rules_json\"name\":\"$name\",\"domain\":\"$domain\",\"ip\":\"$ip\",\"action\":\"$action\""
        [ -n "$src_mac" ] && rules_json="$rules_json, \"src_mac\":\"$src_mac\""
        [ -n "$weekdays" ] && rules_json="$rules_json, \"weekdays\":\"$weekdays\""
        [ -n "$start_time" ] && rules_json="$rules_json, \"start_time\":\"$start_time\""
        [ -n "$stop_time" ] && rules_json="$rules_json, \"stop_time\":\"$stop_time\""
        rules_json="$rules_json}"
    done

    rules_json="$rules_json]"

    json_response "success" "Rules retrieved successfully" "{\"rules\": $rules_json}"
}

# Function to add a new filter rule
add_rule() {
    local rule_name="$1"
    local domain="$2"
    local action="$3"     # "block" or "allow"
    local src_mac="$4"    # Optional MAC address filter
    local weekdays="$5"   # Optional weekdays
    local start_time="$6" # Optional start time
    local stop_time="$7"  # Optional stop time

    if [ -n "$src_mac" ]; then src_mac=$(urldecode "$src_mac"); fi
    if [ -n "$weekdays" ]; then weekdays=$(urldecode "$weekdays"); fi
    if [ -n "$start_time" ]; then start_time=$(urldecode "$start_time"); fi
    if [ -n "$stop_time" ]; then stop_time=$(urldecode "$stop_time"); fi

    # Validation
    if [ -z "$rule_name" ] || [ -z "$domain" ] || [ -z "$action" ]; then
        json_response "error" "Missing required parameters: rule_name, domain, and action are required"
        return 1
    fi

    if ! echo "$rule_name" | grep -q "^custom-filter-"; then
        json_response "error" "Rule name must start with 'custom-filter-'"
        return 1
    fi

    if [ "$action" != "block" ] && [ "$action" != "allow" ]; then
        json_response "error" "Action must be either 'block' or 'allow'"
        return 1
    fi

    # Check if rule already exists
    if uci show firewall 2>/dev/null | grep -q "name='$rule_name'"; then
        json_response "error" "Rule '$rule_name' already exists"
        return 1
    fi

    # Resolve domain to IP
    local ip=$(nslookup -type=A "$domain" 2>/dev/null | grep -A1 'Name:' | grep 'Address:' | tail -n1 | awk '{print $2}')
    if [ -z "$ip" ]; then
        json_response "error" "Could not resolve domain '$domain'"
        return 1
    fi

    # Add firewall rule directly in UCI
    local section=$(uci add firewall rule)
    uci set firewall.@rule[-1].name="$rule_name"
    uci set firewall.@rule[-1].src="lan"
    uci set firewall.@rule[-1].dest="wan"
    uci set firewall.@rule[-1].proto="all"
    uci set firewall.@rule[-1].dest_ip="$ip"
    uci set firewall.@rule[-1].domain="$domain"   # Store original domain

    if [ -n "$src_mac" ]; then
        uci set firewall.@rule[-1].src_mac="$src_mac"
    fi

    if [ "$action" = "block" ]; then
        uci set firewall.@rule[-1].target="REJECT"
    else
        uci set firewall.@rule[-1].target="ACCEPT"
    fi

    if [ -n "$weekdays" ]; then
        uci set firewall.@rule[-1].weekdays="$weekdays"
    fi
    if [ -n "$start_time" ]; then
        uci set firewall.@rule[-1].start_time="$start_time"
    fi
    if [ -n "$stop_time" ]; then
        uci set firewall.@rule[-1].stop_time="$stop_time"
    fi

    uci commit firewall
    /etc/init.d/firewall reload

    rule_data="{\"name\": \"$rule_name\", \"domain\": \"$domain\", \"ip\": \"$ip\", \"action\": \"$action\""
    [ -n "$src_mac" ] && rule_data="$rule_data, \"src_mac\": \"$src_mac\""
    [ -n "$weekdays" ] && rule_data="$rule_data, \"weekdays\": \"$weekdays\""
    [ -n "$start_time" ] && rule_data="$rule_data, \"start_time\": \"$start_time\""
    [ -n "$stop_time" ] && rule_data="$rule_data, \"stop_time\": \"$stop_time\""
    rule_data="$rule_data}"

    json_response "success" "Rule added successfully" "$rule_data"
}

# Function to delete a filter rule
delete_rule() {
    local rule_name="$1"

    if [ -z "$rule_name" ]; then
        json_response "error" "Missing rule name parameter"
        return 1
    fi

    # Find UCI section for rule
    local rule_section=$(uci show firewall 2>/dev/null | grep "name='$rule_name'" | cut -d. -f1-2)
    if [ -z "$rule_section" ]; then
        json_response "error" "Rule '$rule_name' not found"
        return 1
    fi

    uci delete "$rule_section"
    uci commit firewall
    /etc/init.d/firewall reload

    json_response "success" "Rule '$rule_name' deleted successfully"
}

# Function to get system status
get_status() {
    local total_rules=$(uci show firewall 2>/dev/null | grep "name='custom-filter-" | wc -l)
    status_data="{\"total_rules\": $total_rules}"
    json_response "success" "System status retrieved" "$status_data"
}

# Main command processing
case "$cmd" in
    list)
        list_rules
        ;;
    add)
        add_rule "$rule_name" "$domain" "$action" "$src_mac" "$weekdays" "$start_time" "$stop_time"
        ;;
    delete)
        delete_rule "$rule_name"
        ;;
    status)
        get_status
        ;;
    *)
        json_response "error" "Invalid command. Available commands: list, add, delete, status" '{"available_commands": ["list", "add", "delete", "status"]}'
        ;;
esac

exit 0
